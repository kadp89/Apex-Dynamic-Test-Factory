This is a giant, messy, recursive hack which attempts to query the entire schema of an org, filter out the objects which are createable, and create one of each. The flow of the program is as such:

It first calls getGlobalDescribe(). Then, iterates through the returned map and attempts to filter out the backend sObjects. Those it doesn't filter out are created as generic sObjects. Through each of these objects, we populate a field set and iterate through those. If the field is required and NOT a reference, that field is populated with either a random or a hard-coded generic value. If the field is required and IS a reference, we create an instance of a wrapper object and, to preserve reference, push that new object to a global list of those wrappers.Then, it tries a first-pass insert based on "known" (in a guessy kind of way) lack of required foreign keys to try to get a baseline list of parents pushed to the database. If the argument resolveDependencies is true, we call the resolution helper function, which then populates a global(!) Map<SObjectType,Id> of those objects. We then recursively try to resolve dependencies by checking the getReferenceTo() value, diffused through some Schema functions, against the global Map<SObjectType,Id>. For each run of the recursive function, we attempt to put the reference field with the Id gotten from the Map. In this way we resolve dependencies one level at a time. When we detect that the list of unresolved objects hasn't changed between recursions, we return the Ids of what we were able to push.

It doesn't really work, but it was fun and taught me a lot about the Schema namespace and metaprogramming in a general sense, as well as illuminated a bunch of (to me) unknown edge cases and instances of undefined behavior. 

THIS IS NOT PRODUCTION-READY CODE, which you will readily divine should you take the chance of diving into the .cls file. 
